import pandas as pd
import numpy as np
import chess
import os, sys

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import functions
import re
import matplotlib.pyplot as plt


def reduceDataset(puzzles: str, minPlays: int):
    """
    This function takes a CSV puzzle dataset and reduces it to only include puzzles played at least minPlay times
    The new dataset will be saved with the same name, just minPlay added at the end
    puzzles: str
        The path to the CSV file
    minPlays: int
        The minimum number of games in order to be included in the new dataset
    """
    df = pd.read_csv(puzzles)
    ndf = df[df['NbPlays'] >= minPlays]
    ndf.reset_index()
    ndf.to_csv(f'{puzzles[:-4]}-{minPlays}.csv')


def getMovePolicy(lc0: chess.engine, position: chess.Board, move: str) -> float:
    """
    lc0: chess.engine
        Leela, generated by configureEngine
    position: chess.Board
        The position as a chess.Board
    move: str
        The move for which the policy is calculated
    return -> float
        The policy for the given move in the given position
    """
    info = lc0.analysis(position, chess.engine.Limit(nodes=1))
    for i in info:
        for j in i.values():
            p = re.findall(r'P: *\d*\.\d\d%', str(j))
            if move in str(j) and p:
                return round(float(p[0].split(' ')[-1][:-1]), 2)
    # Here castling is represented by e1a1 and e1h1 instead of the standard e1c1 and e1g1
    if move == 'e1g1':
        return getMovePolicy(lc0, position, 'e1h1')
    if move == 'e1c1':
        return getMovePolicy(lc0, position, 'e1a1')
    if move == 'e8g8':
        return getMovePolicy(lc0, position, 'e8h8')
    if move == 'e8c8':
        return getMovePolicy(lc0, position, 'e8a8')
    print(f'Error: FEN: {position.fen()}, move: {move}') 
    return None


def firstMovePolicy(lc0: chess.engine, FEN: str, solution: str, setup: bool = True) -> float:
    """
    This function returns the policy of the correct first move in a puzzle
    leela: chess.engine
        Configured LC0 engine to determine the policy
    FEN: str
        The FEN string of the puzzle
    solution: str
        The solution moves (split by spaces)
    setup: bool
        If True, the first move in the solution is the setup move and will be played
    return -> float
        The policy value of the first move in the solution
    """
    board = chess.Board(FEN)
    moves = solution.split(' ')
    if setup:
        board.push_uci(moves[0])
        moves = moves[1:]
    return getMovePolicy(lc0, board, moves[0])


def scatterPlot(x: list, y: list):
    fig, ax = plt.subplots(figsize=(10, 6))
    
    ax.scatter(x, y)
    ax.set_facecolor('#e6f7f2')
    plt.show()


if __name__ == '__main__':
    # reduceDataset('../resources/lichess_puzzles_202409.csv', 100000)
    puzzles = pd.read_csv('../resources/lichess_puzzles_202409-10000.csv')
    # print(len(puzzles))
    # lc0 = functions.configureEngine('lc0', {'WeightsFile': '/Users/julian/chess/nets/largeNet', 'UCI_ShowWDL': 'true', 'VerboseMoveStats': 'true'})
    # networks = ['/home/julian/chess/nets/small.pb.gz', '/home/julian/chess/nets/medium.pb.gz',  '/home/julian/chess/nets/large.pb.gz',   '/home/julian/chess/nets/veryLarge.pb.gz']
    networks = ['/home/julian/chess/nets/small.pb.gz']
    for net in networks:
        print(net)
        lc0 = functions.configureEngine('lc0', {'WeightsFile': net, 'UCI_ShowWDL': 'true', 'VerboseMoveStats': 'true'})
        policies = list()
        for i in puzzles.index:
            policies.append(firstMovePolicy(lc0, puzzles['FEN'][i], puzzles['Moves'][i]))
        lc0.quit()
        print(np.corrcoef(policies, list(puzzles['Rating'])))
    # scatterPlot(policies, list(puzzles['Rating']))
